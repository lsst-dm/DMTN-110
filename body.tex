\section{Introduction} \label{sec:intro}

The proposal made in this document is oriented to have a more functional approach in the environment management for science pipelines builds.

The benefits that can be obtained implementing this proposal are mainly for developers, that will have more control over the environments they are using. 
This will permit a more dynamic evolution of the used environment, therefore to change more often packages available in the public conda channels. This is the case of \textit{numpy}.

The release process will  benefit as the global build time for the science pipelines  will be reduced. 
Reduced build times should allow us to make more frequent releases to give a more stable platform to our end users.

In this moment there are a large number of \textit{stubs} and eups package that are not working as expected.
Implementing this proposal will remove these packages and the overall build process will be more stable.

The effort required to implement this proposal is mainly limited to a small team, that shall take ownership of the environment management activities.


\subsection{Applicable Documents}
% to be added if any


\subsection{Definitions}

This document uses certain terms which are often overloaded -  in this section we define these terms  as intended in this document.

\subsubsection{Environment} \label{sec:envdef}

An environment is a set of libraries, executables and configurations, that are predefined for a specific context or function.

An environment is usually needed in the following contexts:

\begin{itemize}
\item software development: the environment includes all libraries and tools required to build and debug a software product
\item software test and verification: the environment includes, on top of build and debug tools, additional tools to permit/facilitate the testing and validation activities.
\item operations: the environment shall include only tools required for the execution of operational product. It shall not contain any build or debug tool. It shall be optimize for the operational activities. \footnote{In case a problem is found in operation the first thing to do is to replicate it in a different environment, where also debug and further analysis is possible.}
\end{itemize}

These are the most common uses of an environment. Additional scenarios can be identified depending on the needs.

In some cases, for simplicity, the same environment is used in development, tests and operations, but this does not justify the inclusion of the environment definition in the Software Product itself.


\subsubsection{Software Product} \label{sec:swdef}

A Software Product is a component of the subsystem (DM) product tree.
Releases are made of  SW products (\secref{sec:defrelease}).

A SW Product should correspond to a single repository (git package).
Where a SW Product is comprised of multiple git packages
a Github \textit{metapackage} is used to identify the SW Product.
All git packages of the SW product will be dependencies in a Github \textit{metapackage} and released at the same time.
A git package shall be related only to one Software Product.

The following elements should not be part of a Software Product:

\begin{itemize}
\item build tools, otherwise we will have build tools deployed in operations.
\item environment definition, since the environment depends on the final instantiation of the Software Product that are not visible in the development fase.
\end{itemize}

These elements shall follow a parallel development / release process.

Test data should also not be included in a Software Product, however almost always it is for practical reasons.


\subsection{Software Release} \label{sec:defrelease}

A software release is a consciously identified tag of a software product repository
documented with a software release note.
The identifier is usually of the form M.n.p.% and is used also as a tag in the SW repository.
%The tag is created on a release branch after manual checks on the last release candidate (see \secref{sec:releaseprocedure}).

The tag in the Github repository and the software release note shall be sufficient to identify the release, and therefore for a developer
to resolve the dependencies, build the binaries and execute the software.

\subsection{3rd Party Packages}

3rd party packages are those packages that are not developed in DM, and follows their own documentation and release process.


\newpage
\section{Actual Implementation} \label{sec:actual}

\subsection{Development Environment Preparation} \label{sec:envset} 
As at March 2019, the following steps are used to set-up a build environment for the science pipelines:

\begin{itemize}
\item clone the GitHub package \url{https://github.com/lsst/lsstsw}
\item moving in the cloned package and deploy the environment: \texttt{./bin/deploy}
\item activate the environment: \texttt{. bin/setup.sh}
\end{itemize}

This will make available locally all tooling required to build the science pipelines source code using the command \texttt{rebuild <-r branch> lsst\_distrib}.

The environment deployed and activate using the above steps corresponds to a fixed revision fo the \textit{scipipe\_conda\_env} git package.
This revision is hardcoded in the \textit{lsstsw} build tool. It is also hardcoded in the \textit{newinstall.sh} distribution script and in the continuous integration scripts versioned in the \textit{jenkins-dm-jobs} GitHub repository.


\subsection{Conda Environment Management} \label{sec:condaenv}

The repository $scipipe\_conda\_env$ defines a list of conda packages to be installed in the conda environment.
These packages are resolved by conda from the default channels.

The $scipipe\_conda\_env$ repository includes two different types of environment definition:

\begin{itemize}
\item {\bf bleed}: it is the list of the conda packages that are required by the science pipelines. No version is specified.
\item {\bf pinned}: it is the list of all conda packages resolved in the environment. This includes the bleed packages and all required dependencies resolved automatically by conda. The precise resolved version is given for each package listed in the file.
\end{itemize}

The \textit{pinned} version of the environment definition is the one used to instantiate the environment for the science pipelines build as specified in the above section \ref{sec:envset}.

The \textit{bleed} version is used to update the \textit{pinned} definition to the latest packages version that have been made available in the public conda channels since the previous update.
The \textit{pinned} file is updated every 6 months approximately.

For the \textit{linux} platform, an extra package is required, \textit{nomkl}. For this reason two different bleed files and two different pinned files are provided.


\newpage
\section{Problems}

\subsection{The High Number of Packages in the Stack} \label{sec:high}

The 17.0 release of the science pipelines stack is composed by 128 packages.

All packages are rebuild all the times a new setup is done. 
Each time a release or a release candidate is done, they are rebuild also, with the effect to slow down considerably the release process.

In reality, a large part of these packages are 3rd party libraries that are not available in the public conda channels, or that requires some changes in order to be used in the science pipelines stack.

These packages are not DM software, and shall not be included in the release, but  they should be considered as part of the conda environment.

In order to move these packages in the conda environment, there are two problems:

\begin{itemize}
\item create and maintain conda packages suitable for DM usage
\item dynamically manage the science pipelines conda environment, in order to be able to include and use new versions of the required packages.
\end{itemize}

See appendix \ref{sec:tomove} for a list of packages proposed to be moved to the conda environment.

The expected benefits are:

\begin{itemize}
\item more efficient environment management;
\item reduced build time and therefore easier to release the science pipelines
\item have a more stable build system
\end{itemize}


\subsection{Static Environment} \label{sec:static}

As described in \ref{sec:actual}, the environment deployed and activated using the actual version of the tooling is hardcoded in few places.

This implies that, each time the environment is updated, the hardcoded value need to be updated, the tools redeployed, and restart from scratch any build or development activities.

The tools used should be able to deploy and activate different environment, without the need to have it hardcoded.


\subsection{Unknown Environment Status} \label{sec:unknown}

In some cases, the science pipelines build is failing due to some packages misalignment.

There should be an easy way to compare the active environment  with a reference one, locally deployed or a reference in \textit{scipipe\_conda\_env}. git package 


\subsection{Missing Usecases}

As a result of the problems exposed above, following use cases should be taken in account:

\begin{itemize}
\item be able to deploy a new conda environment without the need to update and clone lsstsw.
\item be able to activate different conda environments using a lsstsw command.
\item be able to check the differences between the active environment and a different one.
\item record which conda environment has been used for a specific build, and been able to set it up again.
\item be able to setup the correct environment when installing an eups build using \textit{newinstall.sh}.
\item be able to run a CI build using a specific environment reference.
\item be able to manage conda packages for 3rd party libraries.
\end{itemize}


\newpage
\section{Proposed Implementation} \label{sec:proposed}

Follows the proposed changes required to satisfy the above usecases.

\subsection{Define Environment References} \label{sec:envDefine}

The package \textit{scipipe\_conda\_env} to be tagged in GitHub for each weekly and each time an eups tag is created.

All changes implemented in the \textit{scipipe\_conda\_env} repository shall follow the usual development process.  
The tooling improvements proposed bellow, will permit the validation of those changes and include them in the development workflow.


\subsection{Use Different Environments in lsstsw Git Package} \label{sec:envActivate}

A new command, or command line option, shall be added to lsstsw to deploy and activate a specific conda environment reference from the \textit{scipipe\_conda\_env} GitHub package.

The possible options should be:

\begin{itemize}
\item deploy/activate a specific \textit{scipipe\_conda\_env} hash
\item deploy/activate a specific \textit{scipipe\_conda\_env} branch
\item deploy/activate a specific \textit{scipipe\_conda\_env} tag
\item deploy/activate the tip of \textit{scipipe\_conda\_env} master
\end{itemize}

This can be done with the following changes in lsstsw package.

\subsubsection{Update deploy Command} \label{sec:deploy}

The \textbf{deploy} lsstsw command should accept the environment reference \textbf{envref}  as an additional command line option.

The default behavior should be the same as now. If no envref is provided, the usual fixed hash shall be deployed. 
%In the future the default behavior can be changed to deploy the last master hash of the \textit{scipipe\_conda\_env} package.

In case the envref is \textit{master}, it shall deploy the latest master, if not already deployed.
In this way, this option can be used to check if there is a newer master version of the conda environment and deploy it.


\subsubsection{Update rebuild Command} \label{sec:rebuild}

The \textbf{rebuild} command should record in a local file the environment reference used for each build.

This will permit in the future to retrieve the information, in order to set-up the same conda environment if required.
%An additional option can be added to the \texttt{rebuild} command, in order to list the existing builds and the corresponding environment used.


\subsubsection{New envconfig Command} \label{sec:envconfig}

A new command shall be added, that permits to choose which environment to activate.

It shall accept one of following options:

\begin{itemize}
\item a \textit{scipipe\_conda\_env} environment reference to activate
\item an existing build number, in order to activate the environment that has been used for that build.
\item list the available environments
\item compare the active environment with an other one, a \textit{scipipe\_conda\_env} reference or a deployed environment
\end{itemize}

If no option is provided, the default reference shall be activated, in order to keep the current behavior.


\subsection{Changes to lsst/lsst Git Package} \label{sec:newinstall}

The distribution script \textit{newinstall.sh} should be updated, or a new command added in order to be able to deploy and activate the environment corresponding to the eups tag that is going to be installed.

%The \textit{newinstall.sh} script should be at this point release independent, and could be integrated into lsstsw. 
%The same command described in \ref{sec:envconfix} could be used to activate the correct environment.


\subsection{Changes to Jenkins builds} \label{sec:cibuilds}

The Jenkins jobs, for example \textit{run-rebuild}, shall be updated in order to accept an environment reference as an optional parameter.
In this way it will be possible to verify that the science pipelines builds with a new environment.


\subsection{Conda Packaging 3rd Party Libraires} \label{sec:3rdpkgs}

The 3rd party libraries included in the conda environment at today March 2019, are all stable and do not require specific build nor customization.

Some of the packages listed in appendix \ref{sec:tomove} are already available in conda-forge channel or \textit{PyPi} (see following \ref{secpypi}).
They are now included in the science pipelines stack as eups packages since when they was needed, they was not available in any conda channels, or it was simpler to handle as eups packages.

For the packages that are not already available, some work need to be done in order to provide and maintain a proper recipe. See \ref{sec:3rddmpkgs} for details.

The packages that are not stable, and may required a considerable number of changes during the time, it is recommended to keep them as eups packages and therefor included in the science pipelines stack.


\subsubsection{3rd Party DM Packages}

The majority of the packages, are requiring some patch or configuration to be applied, in order to be included in the science pipelines stack.

These changes are not happening very often, in average less than every 6 months.

For this packages, we need to define and maintain a conda recipe that provides a package that can be used by the science pipelines stack.

This packages shall have a different name, in order to identify them as special packages produced for DM usage.
If the \textit{conda-forge} channel cannot be used, a specific lsst-dm channel shall be created.

The DM packages shall be dismissed, not maintained anymore, as soon as the needed changes have been incorporated and made available in the official conda distribution.


\subsubsection{PyPi Packages} \label{sec:pypi}

The conda environment definition files in \textit{scipipe\_conda\_env} can accept also pip package. 

This imply that packages available in \textit{PyPi} package repository and that can be installed in the environment. 
However, if available, the preference shall be given to the conda package.


\newpage
\section{Further Improvements}

Considering the inclusion of the 3rd party libraries listed in appendix \ref{sec:tomove} as a first step, follows a list of activities that can improve the overall DM codebase management and increase its availability.

\begin{itemize}
\item create conda packages for the main DM tools used for the build process, such as eups, sconsutils, lsst\_build. 
\item create conda packages for all DM software.
\end{itemize}

This will permit to apply semantic versioning to each git package, and therefore have proper dependency management.


\newpage
\appendix
\section{Packages to be Moved} \label{sec:tomove}

The following (eups) packages are proposed to be moved from science pipelines to the conda environment:

\begin{itemize}
\item apr (*)
\item apr\_util (*)
\item astrometry\_net
\item astropy (*)
\item boost (*)
\item cfitsio (*)
\item coord
\item doxygen (*)
\item eigen (*)
\item esutil
\item fftw (*)
\item flake8
\item galsim
\item gsl (*)
\item healpy
\item libyaml
\item lmfit
\item log4cxx (*)
\item mathplotlib (*)
\item minuit2 (*)
\item mpi
\item mpi4py
\item mpich
\item numpy (*)
\item ndarray (*)
\item pep8\_naming (*)
\item pybind11 (*)
\item pycodestyle
\item pyflakes
\item pykg\_config
\item python\_coverage
\item python\_execnet
\item python\_future
\item python\_psutil
\item python\_py
\item pytest (*)
\item pytest\_cov (*)
\item pytest\_forked
\item pytest\_flake8 (*)
\item pytest\_session2file (*)
\item pytest\_xdist (*)
\item python\_mccabe
\item pyyaml (*)
\item requests
\item scipy
\item scons (*)
\item sqlalchemy
\item starlink\_ast
\item treecorr
\item wcslib
\item ws4py
\end{itemize}

In the \jira{DM-15495} exercise, we manage to build \textit{afw} moving the 3rd party libraries marked with \textbf{(*)} to the conda environment definition.

Other packages, like for example \textit{starlink\_ast}, may require additional work in order to have them available as a conda package.
This can be done in a second time.


%\newpage
%\section{} \label{sec:}
