\section{Introduction} \label{sec:intro}

The proposal made in this document is oriented to have a more functional approach in the environment management for science pipelines builds.

The benefits that can be obtained by implementing this proposal are mainly for developers, who will have more control over the environments they are using. 
This will permit a more dynamic evolution of the used environment, therefore to change more often packages available in the public conda channels. This is the case with \textit{numpy} where new releases are usually binary incompatible.

The release process will  benefit as the global build time for the science pipelines  will be reduced. 
Reduced build times should allow us to make more frequent releases. 
This will be very important during commissioning and the first operations, when multiple releases per day can be requested.

In this moment there are a few \textit{stubs} as EUPS package that are not always working as expected.
Implementing this proposal will remove these packages and the overall build process will be more robust.

The effort required to implement this proposal is mainly limited to a small team, that shall take ownership of the environment management activities.


\subsection{Applicable Documents}
% to be added if any


\subsection{Definitions}

This document uses certain terms which are often overloaded. In this section we define these terms  as intended in this document.

\subsubsection{Environment} \label{sec:envdef}

An environment is a set of libraries, executables and configurations, that are predefined for a specific context or function.

An environment is usually needed in the following contexts:

\begin{itemize}
\item software development: the environment includes all libraries and tools required to build and debug a software product
\item software test and verification: the environment includes, on top of build and debug tools, additional tools to permit/facilitate the testing and validation activities.
\item operations: the environment shall include only tools required for the execution of operational product. It shall not contain any build or debug tool. It shall be optimized for the operational activities. \footnote{In case a problem is found in operation the first thing to do is to replicate it in a different environment, where also debug and further analysis is possible.}
\end{itemize}

These are the most common uses of an environment. Additional scenarios can be identified depending on the needs.

In some cases, for simplicity, the same environment is used in development, tests and operations, but this does not justify the inclusion of the environment definition in the Software Product itself.


\subsubsection{Software Product} \label{sec:swdef}

A Software Product is a component of the subsystem (DM) product tree.

The following activities are done on a SW Product:
\begin{itemize}
\item development activities
\item test activities, usually unit tests and system test
\item release activities
\item packaging activities
\item operations activities, stand alone, in an operational pipeline, or as part of a service. Some SW Products are libraries, therefore are not used operationally directly, but used as dependencies by other Software Products.
\end{itemize}
%Releases are made of  Software Products (\secref{sec:defrelease}).

A Software Product shall correspond to a single repository (git package). All its dependences are also a Software Product and therefore released separately. However, this is not the case for DM.

Where a Software Product is comprised of multiple git packages, a GitHub \textit{metapackage} is used to identify the Software Product.
All git packages of the Software Product will be dependencies in a GitHub \textit{metapackage} and released at the same time.
In this case, a git package shall be related only to one Software Product, and it is not by himself a Software Product.

The following elements should not be part of a Software Product:

\begin{itemize}
\item build tools, otherwise we will have build tools deployed in operations.
\item environment definition, since the environment depends on the final instantiation of the Software Product that are not visible in the development phase.
\end{itemize}

These elements shall follow a parallel development / release process.

Test data should also not be included in a Software Product. However including small datasets for enabling the unit tests is not a bad practice.


\subsection{Software Release} \label{sec:defrelease}

A software release is a consciously identified tag of a Software Product repository documented with a software release note.
The identifier is usually of the form M.n.p.

The tag in the Github repository and the software release note shall be sufficient to identify the release, and therefore for a developer
to resolve the dependencies, build the binaries and execute the software.

The software release is a monolithic snapshot of the Software Product to be used as is, or in its corresponding binary package(s), by the downstream processes or users.


\subsection{Third Party Packages}

3rd party packages are those packages that are not developed in DM, and follow their own documentation and release process.


\newpage
\section{Current Implementation} \label{sec:actual}

\subsection{Development Environment Preparation} \label{sec:envset} 
As of March 2019, the following steps are used to configure a build environment for the Science Pipelines:

\begin{itemize}
\item clone the GitHub package \url{https://github.com/lsst/lsstsw}
\item deploy the environment using \texttt{./bin/deploy}
\item activate the environment by sourcing \texttt{bin/setup.sh}
\end{itemize}

This will make available locally all tooling required to build the science pipelines source code using the command \texttt{rebuild <-r ref> lsst\_distrib}.

The environment deployed and activate using the above steps corresponds to a fixed revision fo the \textit{scipipe\_conda\_env} git package.
This revision is hardcoded in the \textit{lsstsw} build tool. It is also hardcoded in the \textit{newinstall.sh} distribution script and in the continuous integration scripts versioned in the \textit{jenkins-dm-jobs} GitHub repository.


\subsection{Conda Environment Management} \label{sec:condaenv}

The repository $scipipe\_conda\_env$ defines a list of conda packages to be installed in the conda environment.
These packages are resolved by conda from the default channels.

The $scipipe\_conda\_env$ repository includes two different types of environment definition:

\begin{itemize}
\item {\bf bleed}: the list of the conda packages that are required by the science pipelines. No version is specified.
\item {\bf pinned}: the list of all conda packages resolved in the environment. This includes the bleed packages and all required dependencies resolved automatically by conda. The precise resolved version is given for each package listed in the file.
\end{itemize}

The \textit{pinned} version of the environment definition is the one used to instantiate the environment for the science pipelines build as specified in section \ref{sec:envset}.

The \textit{bleed} version is used to update the \textit{pinned} definition to the latest packages version that have been made available in the public conda channels since the previous update.
The \textit{pinned} file is usually updated every 6 months approximately.

For the \textit{linux} platform, an extra package is required, \textit{nomkl}\footnote{See Jira{DM-8146}}. For this reason two different bleed files and two different pinned files are provided.


\newpage
\section{Problems}

\subsection{Large Numbers of Packages} \label{sec:high}

The 17.0 release of the Science Pipelines stack comprises 128 packages.

All packages are rebuilt all the times a new \textit{lsstsw} configuration is done. 
Each time a release or a release candidate is done, they are rebuilt also, with the effect to slow down considerably the release process.

Many of these packages are 3rd party libraries that are not available in the public conda channels, or that require some changes in order to be used in the science pipelines stack.

These packages are not DM software, they are not formally part of the release, and they should be considered as part of the Conda environment.

In order to move these packages to the Conda environment, there are two problems:

\begin{itemize}
\item create and maintain conda packages suitable for DM usage
\item dynamically manage the science pipelines conda environment, in order to be able to include and use new versions of the required packages. This is the critical point.
\end{itemize}

See appendix \ref{sec:tomove} for a list of packages proposed to be moved to the conda environment.

The expected benefits are:

\begin{itemize}
\item more efficient environment management;
\item reduced build time and therefore easier to release the science pipelines
\item have a more stable build system, since reducing the package to build every time will reduce the possibility of random failures.
\end{itemize}


\subsection{Static Environment} \label{sec:static}

As described in section \ref{sec:actual}, the environment deployed and activated using the actual version of the tooling is hardcoded in a few places.

This implies that, each time the environment is updated, the hardcoded value need to be updated, the tools redeployed, and restart from scratch any build or development activities.
The main reason of this, is because of incompatibilities between the EUPS builds and the Conda environment, that are not traced by EUPS.

The tools used should be able to deploy and activate different environment, without the need to have it hardcoded.


\subsection{Unknown Environment Status} \label{sec:unknown}

In some cases, the science pipelines build is failing due to some packages misalignment. 
It is very common to see support requests on \textit{slack} channels, that end up been a problem of Conda environment.

Since a developer is not constraint to use the recommended environment, there should be an easy way to compare the active environment  with a reference one, locally deployed or a reference in \textit{scipipe\_conda\_env}. git package.


\subsection{Missing Usecases}

As a result of the problems exposed above, following use cases should be taken in account:

\begin{itemize}
\item be able to deploy a new conda environment without the need to update and clone lsstsw.
\item be able to activate different conda environments using a lsstsw command.
\item be able to check the differences between the active environment and a different one.
\item record which conda environment has been used for a specific build, and been able to activate it again.
\item be able to activate the correct environment when installing an eups build using \texttt{eups distrib install}.
\item be able to run a CI build using a specific environment reference.
\item be able to manage conda packages for 3rd party libraries.
\end{itemize}


\newpage
\section{Proposed Implementation} \label{sec:proposed}

Here follows the proposed changes required to satisfy the usecases from the previous section.

\subsection{Define Environment References} \label{sec:envDefine}

The package \textit{scipipe\_conda\_env} to be tagged in GitHub for each weekly and each time an EUPS build is created.
This will guarantee that each EUPS weekly build will have a corresponding well known Conda environment, identified with the same weekly tag, that can be used for rebuilt them. 
The SHA1 can be identified also, but shall not be necessary.

All changes implemented in the \textit{scipipe\_conda\_env} repository shall follow the usual development process.  
The tooling improvements proposed bellow, will permit the validation of those changes and include them in the development workflow.


\subsection{Use Different Environments in lsstsw Git Package} \label{sec:envActivate}

A new command, or command line option, shall be added to lsstsw to deploy and activate a specific conda environment reference from the \textit{scipipe\_conda\_env} GitHub package.

The possible options should be:

\begin{itemize}
\item deploy/activate a specific \textit{scipipe\_conda\_env} hash
\item deploy/activate a specific \textit{scipipe\_conda\_env} branch
\item deploy/activate a specific \textit{scipipe\_conda\_env} tag
\item deploy/activate the tip of \textit{scipipe\_conda\_env} master
\end{itemize}

The environment will have a unique name, not the fixed one that is currently used.

This can be done with the following changes in lsstsw package.

\subsubsection{Update deploy Command} \label{sec:deploy}

The \textbf{deploy} lsstsw command should accept the environment reference \textbf{envref}  as an additional command line option.

The default behavior should be the same as now. If no envref is provided, the usual fixed hash shall be deployed. 

In case the envref is \textit{master}, it shall deploy the latest master, if not already deployed.
In this way, this option can be used to check if there is a newer master version of the conda environment and deploy it.


\subsubsection{Update rebuild Command} \label{sec:rebuild}

The \textbf{rebuild} command should record the environment reference used for each build.

This will permit in the future to retrieve the information, in order to activate manually the same conda environment if required.


\subsubsection{New envconfig Command} \label{sec:envconfig}

A new command shall be added, that permits to choose which environment to activate.

It shall accept one of following options:

\begin{itemize}
\item a \textit{scipipe\_conda\_env} environment reference to activate
\item an existing build number, in order to activate the environment that has been used for that build.
\item list the available environments
\item compare the active environment with an other one, a \textit{scipipe\_conda\_env} reference or a deployed environment
\end{itemize}

If no option is provided, the default reference shall be activated, in order to keep the current behavior.


\subsection{Changes to lsst/lsst Git Package} \label{sec:newinstall}

The distribution script \textit{newinstall.sh} should be updated in order to be able to deploy and activate the environment corresponding to the EUPS build that is going to be installed.

This imply that the generate scripts \textit{loadLSST.*} shall accept an environment parameter as input, and deploy the environment reference before activating it, if not already deployed.


\subsection{Changes to Jenkins builds} \label{sec:cibuilds}

The Jenkins jobs, for example \textit{run-rebuild}, shall be updated in order to accept an environment reference as an optional parameter.
In this way it will be possible to verify that the science pipelines builds with a new environment.


\subsection{Conda Packaging 3rd Party Libraries} \label{sec:3rdpkgs}

The 3rd party libraries included in the conda environment at today March 2019, are all stable and do not require specific build nor customization.

Some of the packages listed in appendix \ref{sec:tomove} are already available in conda-forge channel or \textit{PyPi} (see following \ref{sec:pypi}).
They are now included in the science pipelines stack as EUPS packages since when they were initially needed, they were not available in any conda channels, or it was simpler to handle as EUPS packages.

Some other packages require to be updated more often, therefore they have been included as EUPS packages, since the conda environment is not sufficiently dynamic.

The packages that are not stable, and may required a considerable number of changes during the time, it is recommended to keep them as EUPS packages and therefore included in the science pipelines stack.


\subsubsection{Conda Packages Managed by DM} \label{sec:3rddmpkgs}

For all the packages that are not already available in a public channel, some work need to be done in order to provide and maintain a proper recipe.

These packages shall have a different name, in order to identify them as special packages produced for DM usage.
If the \textit{conda-forge} channel cannot be used, a specific lsst-dm channel shall be created.

The DM packages shall be dismissed, not maintained anymore, as soon as the needed changes have been incorporated and made available in the official conda distribution.


\subsubsection{PyPi Packages} \label{sec:pypi}

The conda environment definition files in \textit{scipipe\_conda\_env} can accept also pip package. 

This implies that packages available in \textit{PyPi} package repository and that can be installed in the environment. 
However, if available, the preference shall be given to the conda package.

In case the pip package will bring into the environment too many PyPi dependencies, DM can decide to maintain a DM recipe for them.


\subsection{Change Control}

Since maintaining conda recipes may require a considerable amount of effort, the DMCCB shall monitor when new packages are added to the environment or are used in the codebase.

Third party packages shall also be censed and documented together with the DM product tree. 
Each package shall have an internal reference person.


\newpage
\section{Further Improvements}

Considering the inclusion of the 3rd party libraries listed in appendix \ref{sec:tomove} as a first step, follows a list of activities that can improve the overall DM codebase management and increase its availability.

\begin{itemize}
\item create conda packages for the main DM tools used for the build process, such as EUPS, sconsUtils, lsst\_build. 
\item create conda packages for all DM software.
\end{itemize}

Implementing the first bullet should not require much effort, but will simplify the tooling we are using for instantiate a new development workspace, such as \textit{lsstsw/deploy} or \textit{newinstall.sh}.

The second bulled is a long term activity, that will permit to apply semantic versioning to each git package, and therefore have proper dependency management.


\newpage
\appendix
\section{Packages to be Moved} \label{sec:tomove}

The following (eups) packages are proposed to be moved from science pipelines to the conda environment:

\begin{itemize}
\item apr (*)
\item apr\_util (*)
\item astrometry\_net
\item astropy (*)
\item boost (*)
\item cfitsio (*)
\item coord
\item doxygen (*)
\item eigen (*)
\item esutil
\item fftw (*)
\item flake8
\item galsim
\item gsl (*)
\item healpy
\item libyaml
\item lmfit
\item log4cxx (*)
\item mathplotlib (*)
\item minuit2 (*)
\item mpi
\item mpi4py
\item mpich
\item numpy (*)
\item ndarray (*)
\item pep8\_naming (*)
\item pybind11 (*)
\item pycodestyle
\item pyflakes
\item pykg\_config
\item python\_coverage
\item python\_execnet
\item python\_future
\item python\_psutil
\item python\_py
\item pytest (*)
\item pytest\_cov (*)
\item pytest\_forked
\item pytest\_flake8 (*)
\item pytest\_session2file (*)
\item pytest\_xdist (*)
\item python\_mccabe
\item pyyaml (*)
\item requests
\item scipy
\item scons (*)
\item sqlalchemy
\item starlink\_ast
\item treecorr
\item wcslib
\item ws4py
\end{itemize}

In the \jira{DM-15495} exercise, we manage to build \textit{afw} moving the 3rd party libraries marked with \textbf{(*)} to the conda environment definition.

Other packages, like for example \textit{starlink\_ast}, may require additional work in order to have them available as a conda package.
This can be done in a second time.


%\newpage
%\section{} \label{sec:}
